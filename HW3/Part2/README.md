### Strategy
The strategy that was followed for this task was to make the implementation take advantage of Javas PriorityBlockingQueue, which is the same as a normal priority queue only with the addition of it being thread safe. Like any priority queue, insertion and deletion takes O(log(n)) time, in our ase n being the number of minutes the sensors (threads) run (one hour so 60 minutes) * the number of sensors (threads) running (8) so O(log(480)) for each of the three priority queues that are keeping track of differential on ten minute intervals, highest temp and lowest temp. Once the threads are done running, analysis is simple since the queues can just be polled to get the top values in O(1) time.